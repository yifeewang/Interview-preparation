在浏览器中，采用的主要垃圾回收算法为`标记清除算法`和`分代回收算法`。以下是这两种算法在浏览器中的使用方式：

## 1. 标记清除算法在浏览器中的使用方式
在浏览器中，所有的 JavaScript 对象都存储在堆（Heap）中，垃圾回收器会定期运行，从根对象`window`出发检查所有的对象，并将`不可达对象`标记为可回收的垃圾对象。垃圾回收器会将所有被标记的垃圾对象进行清除。标记清除算法的优点是能够解决循环引用的问题，避免内存泄漏。在处理对象比较少的情况下，效率也比较高。但是，标记清除算法可能会造成运行时的暂停，因为垃圾回收器需要暂停程序并扫描所有对象，这可能会影响网页的响应速度。
以下是标记清除算法的一个示例：

假设我们有以下代码：
```js
let obj1 = { name: 'Tom' };
let obj2 = { name: 'Jerry' };
let obj3 = { name: 'Spike' };

obj1.friend = obj2;
obj2.friend = obj3;
obj3.friend = obj1;

// 现在将 obj1 对象从变量中移除
obj1 = null;
```
在这个例子中，我们创建了三个对象 obj1、obj2 和 obj3，并分别将它们相互关联。这些对象一起组成了一个环状结构，如果没有采取垃圾回收措施，它们将一直存在于内存中，占用大量空间。

当我们将 obj1 变量移除时，如果 JavaScript 引擎采用标记清除算法，它会启动垃圾回收器，从根对象开始扫描所有对象。在这个例子中，根对象是全局对象 window，而 obj2 和 obj3 对象可以通过 obj1 对象访问到。垃圾回收器会标记这些对象为“活动对象”，表示它们目前仍然可以被程序使用。

接着，垃圾回收器会扫描被这些活动对象所引用的其他对象，标记它们为活动对象。在这个例子中，obj2.friend 指向 obj3 对象，因此垃圾回收器会将 obj3 对象标记为活动对象。垃圾回收器依此类推，直到所有被引用的对象被标记为活动对象。

当所有需要的对象都被标记为活动对象后，垃圾回收器会扫描所有对象，将未被标记的对象清除出堆内存。在这个例子中，由于 obj1 变量被移除，它指向的对象已经无法从其他活动对象中访问到，因此它将被标记为垃圾对象，最终被垃圾回收器从堆内存中清除。

`优点：`

简单易懂：标记清除算法相对于其他算法来说较为简单，实现起来也相对简单明了。

效率高：标记清除算法对标记无用对象的扫描使用了递归实现，跳过无需回收的对象，可以更快速地完成垃圾回收。

`缺点：`

程序运行暂停时间长：标记清除算法在进行垃圾回收时需要遍历整个堆内存，这可能导致程序暂停一段时间，对性能有所影响。

内存碎片问题：由于删除无用对象时，仅仅是将其标记为可回收，而没有真正释放所占据的内存空间，这可能会导致堆内存出现大量的内存碎片，影响垃圾回收器的效率。

循环引用问题：标记清除算法无法处理循环引用的对象，这会导致这些对象一直保存在堆内存中，无法被释放，形成内存泄漏。

## 2. 分代回收算法在浏览器中的使用方式
分代回收算法是一种常见的垃圾回收算法，它将对象按照其生命周期的不同阶段分为不同代。一般情况下，新创建的对象会放在第0代，而经过多次垃圾回收依然存在的对象会被提升到高代，垃圾回收的频率也会随着代数的增加而逐渐降低，以此提高垃圾回收效率。

以下是一个简单的分代回收算法的示例：
假设我们有一个空数组：
```js
let arr = [];

// 向数组中添加一万个对象
for (let i = 0; i < 10000; i++) {
  arr.push({
    id: i,
    value: Math.random()
  });
}
```
在这个例子中，我们创建了一个空数组 arr，并向其中添加了一万个随机对象。由于这些对象都是新创建的，它们会被分配到第0代。当垃圾回收器运行时，它会将第0代中不再需要的对象清除出堆内存。

接下来，我们向这些对象添加一些属性，将它们变得更加复杂：
```js
for (let obj of arr) {
  obj.friends = [];

  // 向对象的朋友列表中添加另外五个随机对象
  for (let i = 0; i < 5; i++) {
    obj.friends.push({
      id: i,
      value: Math.random()
    });
  }
}
```
在这段代码中，我们向每个对象添加了一个名为 friends 的数组属性，并向其中添加了另外五个随机对象。
这时，我们的对象变得更加复杂，不再适合放在第0代。为了提高垃圾回收的效率，我们可以将这些对象提升到第1代：

```js
// 创建一个新的空数组
let newArray = [];

// 将原数组中的所有对象复制到新数组中
for (let obj of arr) {
  newArray.push(obj);
}

// 将新数组赋值给原数组
arr = newArray;
```
在这段代码中，我们创建了一个新的空数组 newArray，并将原数组 arr 中的所有对象复制到新数组中。由于这些对象的生命周期较长，它们会被分配到第1代。为了防止原数组 arr 中的对象被垃圾回收器清除，我们将新数组 newArray 赋值给原数组 arr。

分代回收算法的`核心思想`是通过将`对象分组管理，针对不同代数采用不同的垃圾回收策略，以此提高垃圾回收的效率`。通常情况下，新创建的对象会被放在第0代，而生命周期较长的对象则会被提升到高代，以此降低垃圾回收的频率，提高程序的性能。

`优点：`

提高垃圾回收效率：通过将对象分组管理，针对不同代数采用不同的垃圾回收策略，以此提高垃圾回收的效率。

减少关闭时间：与标记清除算法不同，分代回收算法只会对部分堆进行扫描，因此可以在较短的时间内完成垃圾回收。

解决循环引用问题：通过将对象分为不同代，可以避免循环引用问题，因为每个代中的对象生存时间不同。

`缺点：`

内存分配问题：对象的代数是根据其生命周期分配的，如果一个对象在某个阶段频繁创建和销毁，它可能被提升到高代，这可能会影响垃圾回收的效率。

内存消耗：由于分代回收算法需要维护多个代，因此可能会占用更多的内存空间。

实现复杂度：相对于标记清除算法和引用计数算法来说，分代回收算法的实现较为复杂，需要在内存管理和垃圾回收策略上做出更多的考虑。

## 3. 引用计数算法在浏览器中的使用方式
在浏览器中，循环引用是引用计数算法的主要缺陷，因此引用计数算法在浏览器中的应用非常有限。

`引用计数算法`是一种垃圾回收算法，它通过跟踪每个对象被引用的次数来确定哪些对象可以被垃圾回收。
每当一个对象被引用，它的引用计数器就会增加1；当一个对象的引用被删除或离开作用域时，它的引用计数器就会减1。
当一个对象的引用计数器变为0时，这个对象将被垃圾回收器回收。

以下是一个简单的引用计数算法的示例：
```js
let obj1 = {value: "obj1"};
let obj2 = {value: "obj2"};

obj1.ref = obj2;  // obj1引用了obj2
obj2.ref = obj1;  // obj2引用了obj1

obj1 = null;  // obj1的引用被删除
obj2 = null;  // obj2的引用被删除
```
在这个例子中，我们创建了两个对象 obj1 和 obj2，并互相引用了彼此。当其中一个对象的引用被删除时，它的引用计数器就会减1。
在这个示例中，当我们将 obj1 和 obj2 的引用都删除时，它们的引用计数器都变成了0，因此这两个对象都会被垃圾回收器回收

`引用计数算法的优点如下`：

实时性：引用计数算法能够在对象变为垃圾时立即将其回收，因为垃圾回收的判断是基于引用计数器的，而不是等待某个特定的时间点或事件。

最小化暂停时间：引用计数算法不需要扫描整个堆内存，因此其停顿时间相对较短。

`引用计数算法的缺点如下`：

循环引用问题：当两个对象互相引用时，它们的引用计数会一直保持不为0，因此这两个对象会一直存在于堆内存中，无法被垃圾回收器回收，这就是循环引用问题。

计数器更新和管理开销：引用计数算法需要跟踪每个对象的引用计数，并在引用被删除或离开作用域时及时更新引用计数器。这会引起一定的计算开销和内存开销，如果对象的引用频繁增减，系统将会有很大的开销。

总的来说，引用计数算法在某些情况下表现良好，但是循环引用问题是一个无法解决的难题，这种算法的应用已经越来越少了。